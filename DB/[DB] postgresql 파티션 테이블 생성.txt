[DB - Postgresql 파티션 테이블 생성]

# 파티션(상속)사용 이유
	파티션 테이블은 대규모 데이터베이스 환경에서 유용함
	- 성능
		- 데이터가 조건에 따라서 여러 파티션에 저장되어 특정 파티션에서만 검색하므로 데이터 읽기 속도가 빨라짐
		- 각 파티션마다 개별적으로 인덱스를 생성하고 관리 할 수 있음
	
	- 데이터 관리
		- 보관주기에 따른 데이터들을 관리하기 편리함 
			ex) 접속기록과 같이 보관주기가 있는 데이터
	
	- 확장성 및 유연성
		- 데이터가 계속 증가할때는 새 파티션을 추가하여서 관리하는것이 용이함
		- PostgreSQL은 RANGE , LIST , HASH 등 다양한 파티션 전략을 지원함
	- 병렬처리
		- 각 파티션을 동시에 처리함으로써 데이터 삽입, 업데이트, 삭제의 병렬성이 높아짐
		- 당연히 병렬처리를 하므로 전체적인 성능도 좋아짐

# 파티션 / 상속 테이블의 차이점
	상속테이블 : RDB에서 부모-자식 관계를 표현하기위한 기능
	파티션 테이블 : 대량의 데이터를 보다 효율적으로 관리하고 쿼리 성능을 최적화할 수 있는 기능

	- 목적
		상속 테이블 : 
			- 테이블간의 관계를 표시하는 방식이며, 하나의 부모테이블에서 공통적으로 사용하는 컬럼을 정의하고 자식 테이블은 부모의 구조를 상속받음
			- 상속은 사용자의 정의에 따라서 데이터가 분산되지 않을 수 있으며, 데이터 처리를 위해 별도의 트리거나 함수를 사용해야 함
		파티션 테이블 :
			- 파티션 테이블은 주로 데이터의 양이 많을 때 쿼리 성능 향상 및 관리를 용이하게 하기 위해 설계되었음
			- 파티션은 데이터의 물리적 분할을 기반으로 하며, 데이터 삽입 시 적절한 파티션에 데이터가 분산됨
			- 파티션은 주로 RANGE , LIST , HASH 등의 기준으로 테이블을 나눔
	
	- 성능
		상속 테이블 : 
			- 상속 구조에서는 쿼리가 부모 테이블에서 모든 자식 테이블을 검색함
			- 결과가 비효율적일 수 있으며, 쿼리 성능에 악영향을 미침
		파티션 테이블 : 
			- 파티션 테이블은 쿼리가 특정 파티션만 검색하도록 최적화 되어있음
			- 데이터의 논리적 분리로 인해 성능이 향상됨

	- 관리 / 유지보수
		상속 테이블 : 
			- 사용자가 연결된 구조를 명확히 이해하고 있어야 하여 관리가 복잡함
			- 데이터 수정/삭제 작업 시 모든 테이블에 대해 별도의 트리거와 함수를 관리해야함
		파티션 테이블 : 
			- 데이터 삽입시 적절한 파티션에 저장되어 간편함
			- 불필요한 파티션을 삭제하거나 데이터 삭제도 간편함

	- 기능
		상속 테이블 : 
			- 상속테이블은 제한된 기능만 제공하며, 쿼리와 데이터 조작을 위해서 함수를 사용해야 할 때도 있음
		파티션 테이블 : 
			- 다양한 파티션 전략을 지원하며 기본적으로 성능향상과 간편한 데이터 관리를 위해 내장된 기능이 있음
	

# 상속 테이블 생성 방법
	상속 테이블은 아래와 같이 네개가 필요함
	1. 부모테이블 생성
	2. 자식 테이블 생성
	3. 테이블 데이터 분배를 위한 함수 생성
	4. 데이터 insert시 데이터 분배를 위한 트리서 생성

	- 부모 테이블 생성
	=====================================================================

	CREATE TABLE user_log(
		user_id character varying(20) NOT NULL,
		user_log_date character varying(8) NOT NULL
	)
	=====================================================================

	- 자식 테이블 생성
	=====================================================================
	※ 테스트를위해 두개 생성 , 2월 3월 테이블
	CREATE TABLE user_log_202503(
		CONSTRAINT user_log_202503_user_log_date_check CHECK((((user_log_date)::text >='20250301'::text) AND ((user_log_date)::text <='20250331'::text)))
	)INHERITS (user_log);
	CREATE TABLE user_log_202502(
		CONSTRAINT user_log_202503_user_log_date_check CHECK((((user_log_date)::text >='20250201'::text) AND ((user_log_date)::text <='20250231'::text)))
	)INHERITS (user_log);
	=====================================================================

	- Function 생성
	=====================================================================
	CREATE FUNCTION insert_log_data() RETURNS TRIGGER
	LANGUAGE plpgsql
	AS $$
	DECLARE
		p_data TEXT;
		p_table TEXT;
	BEGIN
		-- 'user_log_date'의 앞 6자리를 사용하여 월 단위 테이블 결정
		p_data := substr(NEW.user_log_date, 1, 6);
		p_table := TG_TABLE_NAME || '_' || p_data;

		-- 동적으로 분할 테이블에 INSERT 수행
		EXECUTE format(
			'INSERT INTO %I SELECT $1.*', 
			p_table
		) USING NEW;

		RETURN NULL;  -- INSERT를 부모 테이블에서 하지 않음
	END;
	$$;
	=====================================================================

	- Trigger 생성
	=====================================================================
	CREATE TRIGGER trig_user_log_insert BEFORE INSERT ON user_log FOR EACH ROW EXECUTE PROCEDURE insert_log_data();
	=====================================================================
	
	- 데이터 추가
	=====================================================================
	INSERT INTO user_log (user_id,user_log_date) VALUES('kimsungchul', '20250307');
	INSERT INTO user_log (user_id,user_log_date) VALUES('kimsungchul', '20250207');
	=====================================================================

# 파티션 테이블 생성 방법
	파티션 테이블은 처음 테이블 생성 시 파티션 테이블을 명시해주고 파티션 테이블만 생성하면 함수나 트리거가 필요없이 자동으로 데이터가 분배됨
	1. 원본 테이블 생성
	2. 파티션 테이블 생성

	- 테이블 생성
	=====================================================================
	CREATE TABLE user_log(
		user_id character varying(20) NOT NULL,
		user_log_date character varying(8) NOT NULL
	)PARTITION BY RANGE (user_log_date);

	=====================================================================
	
	- 파티션 테이블 생성
	=====================================================================
	-- 테스트를위해 두개 생성 , 2월 3월 테이블
	CREATE TABLE user_log_202503
		PARTITION OF user_log
		FOR VALUES FROM ('20250301') TO ('20250331');

	CREATE TABLE user_log_202502
		PARTITION OF user_log
		FOR VALUES FROM ('20250201') TO ('20250231');
	=====================================================================

	- 데이터 추가
	=====================================================================
	INSERT INTO user_log (user_id,user_log_date) VALUES('kimsungchul', '20250307');
	INSERT INTO user_log (user_id,user_log_date) VALUES('kimsungchul', '20250207');
	=====================================================================


# 기타
	로컬의 sc_db에서 테스트 했음
